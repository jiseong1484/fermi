<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>상담사 콘솔</title>
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; padding: 16px; max-width: 960px; margin: 0 auto; }
        .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: flex-end; }
        .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin: 12px 0; }
        button { padding: 10px 12px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
        button:disabled { opacity: .5; cursor: not-allowed; }
        input { padding: 10px; border-radius: 10px; border: 1px solid #ccc; }
        .hint { color: #555; font-size: 14px; }
        video { width: 100%; max-height: 320px; background: #000; border-radius: 12px; }
        pre { background: #f6f6f6; padding: 10px; border-radius: 10px; overflow: auto; height: 120px; }
        #call-ui { display: none; }
    </style>
</head>
<body>
<h1>상담사 콘솔</h1>

<div class="card">
    <div class="row">
        <div>
            <label for="agentId">Agent ID</label>
            <input id="agentId" value="agent-1" />
        </div>
        <button id="btnGoOnline">온라인</button>
        <button id="btnNextCall" disabled>다음 통화</button>
    </div>
    <p id="status" class="hint" style="margin-top: 1rem;">오프라인 상태입니다. '온라인' 버튼을 눌러 상담을 시작하세요.</p>
    <div id="queueStatus" class="hint" style="font-weight: bold;"></div>
</div>

<div class="card" id="call-ui">
    <div class="row">
        <button id="btnEndCall">상담 종료</button>
    </div>
    <div class="row" style="margin-top: 1rem;">
        <div style="flex:1;">
            <div class="hint" id="wsStatus">WS: -</div>
            <div class="hint" id="pcStatus">PC: -</div>
            <div class="hint" id="iceStatus">ICE: -</div>
        </div>
        <div style="flex:1;">
            <pre id="log"></pre>
        </div>
    </div>
    <div class="row" style="margin-top: 1rem; gap: 1rem;">
        <div style="flex:1; min-width: 320px;">
            <div class="hint">Local</div>
            <video id="localVideo" autoplay playsinline muted style="transform: scaleX(-1);"></video>
        </div>
        <div style="flex:1; min-width: 320px;">
            <div class="hint">Remote</div>
            <video id="remoteVideo" autoplay playsinline style="transform: scaleX(-1);"></video>
        </div>
    </div>
</div>

<script>
    const $ = (id) => document.getElementById(id);

    let agentId = "";
    let roomId = "";
    let ws = null;
    let pc = null;
    let localStream = null;
    let queueStatusPoller = null;

    function uiLog(...args) {
        console.log(...args);
        const el = $("log");
        el.textContent += args.map(a => (typeof a === "string" ? a : JSON.stringify(a))).join(" ") + "\n";
        el.scrollTop = el.scrollHeight;
    }
    function setText(id, msg) { const el = $(id); if (el) el.textContent = msg; }
    function show(id) { $(id).style.display = 'block'; }
    function hide(id) { $(id).style.display = 'none'; }

    function getWsUrl() {
        return `${location.protocol === "https:" ? "wss" : "ws"}://${location.host}/ws`;
    }

    function getApiBase() {
        return location.origin;
    }

    async function updateQueueSize() {
        try {
            const response = await fetch(`${getApiBase()}/api/queue/size`);
            const data = await response.json();
            if (response.ok) {
                setText("queueStatus", `현재 대기 인원: ${data.size}명`);
            }
        } catch (e) {
            setText("queueStatus", "대기 인원 확인 실패");
        }
    }

    function wsSend(type, payload) {
        const msg = { type, roomId, payload };
        uiLog("[WS ->]", type, "room=", roomId);
        if (!ws || ws.readyState !== 1) return;
        ws.send(JSON.stringify(msg));
    }

    function wsRegister() {
        const msg = { type: "register", userId: agentId };
        uiLog("[WS ->] register", msg);
        ws.send(JSON.stringify(msg));
    }
    
    // 현재 통화 관련 상태만 초기화 (미디어, 기본 WS 연결 유지)
    async function cleanupPeerConnection() {
        if (pc) {
            try { pc.close(); } catch (e) {}
            pc = null;
        }
        setText("pcStatus", "PC: -");
        setText("iceStatus", "ICE: -");
        $("remoteVideo").srcObject = null;
        $("log").textContent = "";
        roomId = "";
        
        // 다시 다음 통화를 받을 수 있도록 버튼 활성화 및 상태 변경
        $("btnEndCall").disabled = true;
        hide("call-ui");
        
        try {
            // 중요: 서버에 상담사 상태를 다시 AVAILABLE로 변경하도록 요청
            const response = await fetch(`${getApiBase()}/api/agents/${agentId}/available`, { method: "POST" });
            if (!response.ok) throw new Error("Failed to reset agent status");
            
            setText("status", "온라인. 다음 통화를 기다리는 중...");
            $("btnNextCall").disabled = false;
            
            // 통화 종료 후 큐 상태 폴링 다시 시작
            updateQueueSize();
            if (queueStatusPoller) clearInterval(queueStatusPoller);
            queueStatusPoller = setInterval(updateQueueSize, 5000);
        } catch (e) {
            setText("status", `상태 초기화 실패: ${e.message}. 페이지를 새로고침하세요.`);
        }
    }
    
    async function startWebRTC() {
        if (!localStream) {
            uiLog("!! Local stream not ready");
            return;
        }
        show("call-ui");
        $("btnEndCall").disabled = false;

        // 통화 시작 시 큐 상태 폴링 중지
        if (queueStatusPoller) clearInterval(queueStatusPoller);
        setText("queueStatus", "");

        const iceConfiguration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' }, // Public STUN server
                // {
                //     urls: "turn:61.74.145.110:3478?transport=udp",
                //     username: "fermi_user",
                //     credential: "411c0df2bd576db828c933c537e8841a"
                // },
                // {
                //     urls: "turns:your-turn-server.com:443?transport=tcp",
                //     username: "your_username",
                //     credential: "your_password"
                // }
            ]
        };
        pc = new RTCPeerConnection(iceConfiguration);

        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        pc.ontrack = (event) => {
            $("remoteVideo").srcObject = event.streams[0];
            uiLog("[PC] ontrack remote stream");
        };

        pc.onicecandidate = (event) => {
            if (event.candidate) {
                uiLog("[ICE local] generated");
                wsSend("candidate", event.candidate);
            }
        };

        pc.onconnectionstatechange = () => setText("pcStatus", `PC: ${pc.connectionState}`);
        pc.oniceconnectionstatechange = () => setText("iceStatus", `ICE: ${pc.iceConnectionState}`);
        setText("pcStatus", "PC: created");

        // Join room, but DO NOT send offer immediately. Wait for peer_ready.
        wsSend("join", {});
    }
    
    // ===== Bootstrapping and Event Handlers =====

    $("btnGoOnline").onclick = async () => {
        agentId = $("agentId").value.trim();
        if (!agentId) {
            alert("상담사 ID를 입력하세요.");
            return;
        }

        $("btnGoOnline").disabled = true;
        setText("status", "카메라/마이크 권한을 허용해주세요...");

        // 1. Get Media
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            $("localVideo").srcObject = localStream;
        } catch (e) {
            setText("status", `미디어 접근 실패: ${e.message}`);
            $("btnGoOnline").disabled = false;
            return;
        }

        // 2. Connect WebSocket
        setText("status", "서버에 연결 중...");
        ws = new WebSocket(getWsUrl());

        ws.onopen = async () => {
            setText("wsStatus", "WS: connected");
            
            // 3. Register and set status to AVAILABLE
            wsRegister();
            try {
                const response = await fetch(`${getApiBase()}/api/agents/${agentId}/available`, { method: "POST" });
                if (!response.ok) throw new Error("Failed to set agent as available");
                
                setText("status", "온라인. '다음 통화' 버튼을 눌러주세요.");
                $("btnNextCall").disabled = false;
                $("agentId").disabled = true; // Don't allow changing ID while online

                // 4. Start polling for queue size
                updateQueueSize(); // initial call
                if (queueStatusPoller) clearInterval(queueStatusPoller);
                queueStatusPoller = setInterval(updateQueueSize, 5000); // every 5 seconds
            } catch (e) {
                setText("status", `온라인 전환 실패: ${e.message}`);
                $("btnGoOnline").disabled = false;
            }
        };

        ws.onclose = () => {
             setText("wsStatus", "WS: closed");
             if (queueStatusPoller) clearInterval(queueStatusPoller);
             // Handle potential disconnects
        };
        ws.onerror = () => { setText("wsStatus", "WS: error"); };
        
        ws.onmessage = async (evt) => {
            let msg;
            try { msg = JSON.parse(evt.data); } 
            catch (e) { console.error("JSON parse failed", e, evt.data); return; }

            uiLog("[WS <-]", msg);

            if (msg.type === "session-matched" && msg.agentId === agentId) {
                roomId = msg.sessionId;
                setText("status", `고객(${msg.customerId})과 연결되었습니다. 통화를 시작합니다...`);
                await startWebRTC(); // This now only sets up PC and joins room, doesn't send offer
            }
            else if (msg.type === "peer_ready" && msg.roomId === roomId) { // NEW: Handle peer_ready signal
                uiLog("[WS] Peer is ready, sending offer.");
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                wsSend("offer", offer);
            }
            else if (msg.type === "answer") {
                if(pc) await pc.setRemoteDescription(msg.payload);
            }
            else if (msg.type === "candidate") {
                if(pc) {
                    try { await pc.addIceCandidate(msg.payload); } catch(e) { console.error(e); }
                }
            }
            else if (msg.type === "ended") {
                uiLog("[CALL] ended by peer", msg.payload);
                await cleanupPeerConnection();
            }
        };
    };

    $("btnNextCall").onclick = async () => {
        if (!agentId) return;

        setText("status", "다음 고객을 찾는 중...");
        $("btnNextCall").disabled = true;

        try {
            const response = await fetch(`${getApiBase()}/api/matching/next`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ agentId })
            });

            const result = await response.json();

            if (response.ok) {
                 setText("status", "고객과 매칭되었습니다. WebSocket을 통해 연결됩니다...");
                 // The session-matched event via WebSocket will trigger the call
            } else {
                 setText("status", `매칭 실패: ${result.reason || '알 수 없는 오류'}. 잠시 후 다시 시도하세요.`);
                 $("btnNextCall").disabled = false; // Re-enable on failure
            }

        } catch (e) {
            setText("status", `매칭 요청 중 오류 발생: ${e.message}`);
            $("btnNextCall").disabled = false;
        }
    };

    $("btnEndCall").onclick = async () => {
        wsSend("ended", { reason: "agent_click" });
        await cleanupPeerConnection();
    };

</script>
</body>
</html>

