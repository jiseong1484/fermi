<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>상담 대기</title>
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; padding: 16px; max-width: 960px; margin: 0 auto; }
        .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin: 12px 0; }
        button { padding: 10px 12px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
        button:disabled { opacity: .5; cursor: not-allowed; }
        video { width: 100%; max-height: 320px; background: #000; border-radius: 12px; }
        .hint { color: #555; font-size: 14px; }
        pre { background: #f6f6f6; padding: 10px; border-radius: 10px; overflow: auto; }
        #call-ui, #co-browsing-container { display: none; }

        /* Co-browsing and Modal Styles */
        #pdf-viewer-container {
            position: relative;
            width: 100%;
            /* height is set by canvas */
            border: 1px solid #ccc;
            min-height: 600px; /* Provide a minimum height */
        }
        #pdf-viewer-container canvas {
            display: block;
            margin: 0 auto;
        }
        #pdf-pagination-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 16px;
            margin-top: 12px;
        }
        #agent-cursor {
            position: absolute;
            width: 24px;
            height: 24px;
            transform: translate(-50%, -50%); /* Center the dot on the cursor */
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="6" fill="rgba(255, 0, 0, 0.4)"/><circle cx="12" cy="12" r="4" fill="red"/></svg>');
            background-size: contain;
            display: none;
            z-index: 10;
            pointer-events: none;
        }
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); display: none; justify-content: center; align-items: center; z-index: 100;
        }
        .modal-content { background: #fff; padding: 20px; border-radius: 12px; text-align: center; }
        #signature-pad-canvas { border: 1px solid #ccc; border-radius: 8px; }
        #keyboard-input { padding: 8px; margin: 10px 0; width: calc(100% - 16px); box-sizing: border-box; }
    </style>
</head>
<body>
<h1>고객 페이지</h1>

<div class="card" id="waiting-ui">
    <h2>상담 대기 중...</h2>
    <p id="status">상담사와 연결을 위해 대기열에 등록하고 있습니다.</p>
    <p class="hint">이 페이지를 닫지 마세요.</p>
</div>

<div class="card" id="call-ui">
    <div class="hint" id="wsStatus">WS: -</div>
    <div class="hint" id="pcStatus">PC: -</div>
    <div class="hint" id="iceStatus">ICE: -</div>
    <button id="btnEndCall" style="margin-top:8px;">통화 종료</button>

    <div style="display: flex; gap: 1rem; margin-top: 1rem;">
        <div style="flex:1; min-width: 320px;">
            <div class="hint">Local</div>
            <video id="localVideo" autoplay playsinline muted style="transform: scaleX(-1);"></video>
        </div>
        <div style="flex:1; min-width: 320px;">
            <div class="hint">Remote</div>
            <video id="remoteVideo" autoplay playsinline style="transform: scaleX(-1);"></video>
        </div>
    </div>
</div>

<!-- Co-browsing UI -->
<div class="card" id="co-browsing-container">
    <h3>공유 문서</h3>
    <div id="pdf-viewer-container">
        <div id="agent-cursor"></div>
        <!-- PDF canvas will be inserted here -->
    </div>
    <div id="pdf-pagination-controls">
        <button id="pdf-prev" disabled>&laquo; 이전</button>
        <span id="pdf-page-info"></span>
        <button id="pdf-next" disabled>다음 &raquo;</button>
    </div>
</div>

<!-- Signature Modal -->
<div class="modal-overlay" id="signature-modal">
    <div class="modal-content">
        <p>아래 영역에 서명해주세요.</p>
        <canvas id="signature-pad-canvas" width="400" height="200"></canvas>
        <div>
            <button id="signature-clear">다시 서명</button>
            <button id="signature-confirm">서명 완료</button>
        </div>
    </div>
</div>

<!-- Keyboard Input Modal -->
<div class="modal-overlay" id="keyboard-modal">
    <div class="modal-content">
        <p>텍스트를 입력해주세요.</p>
        <input type="text" id="keyboard-input" placeholder="여기에 입력하세요" />
        <div>
            <button id="keyboard-cancel">취소</button>
            <button id="keyboard-confirm">확인</button>
        </div>
    </div>
</div>


<pre id="log"></pre>

<!-- JS Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/signature_pad/1.5.3/signature_pad.min.js"></script>
<script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js`;
</script>

<script>
    const $ = (id) => document.getElementById(id);

    let roomId = "";
    let customerId = `customer_${Math.random().toString(36).substring(2, 9)}`;
    let ws = null;
    let pc = null;
    let localStream = null;
    let dataChannel = null;

    // Co-browsing state
    let signaturePad = null;
    let isController = false;
    let pdfDoc = null;
    let currentPageNum = 1;
    let pdfIsLoading = false;
    let pdfFields = []; // Stores field definitions from JSON
    let fieldValues = {}; // Stores current values for fields (signature image, checkbox state, text)
    let activeField = null; // The field currently being interacted with via a modal (signature, keyboard)
    // Checkboxes are now always active, so no special state is needed for highlighting.


    function throttle(func, limit) {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        }
    }

    function uiLog(...args) {
        console.log(...args);
        const el = $("log");
        el.textContent += args.map(a => (typeof a === "string" ? a : JSON.stringify(a))).join(" ") + "\n";
        el.scrollTop = el.scrollHeight;
    }
    function setText(id, msg) { const el = $(id); if (el) el.textContent = msg; }
    function show(id, display = 'block') { $(id).style.display = display; }
    function hide(id) { $(id).style.display = 'none'; }

    function getWsUrl() {
        return `${location.protocol === "https:" ? "wss" : "ws"}://${location.host}/ws`;
    }

    function getApiBase() {
        return location.origin;
    }

    function wsSend(type, payload) {
        const msg = { type, roomId, payload };
        if (!ws || ws.readyState !== 1) return;
        ws.send(JSON.stringify(msg));
    }
    
    function dcSend(type, payload) {
        if (dataChannel && dataChannel.readyState === 'open') {
            const msg = JSON.stringify({ type, payload });
            dataChannel.send(msg);
        }
    }

    function wsRegister() {
        const msg = { type: "register", userId: customerId };
        uiLog("[WS ->] register", msg);
        ws.send(JSON.stringify(msg));
    }
    
    async function joinQueue() {
        setText("status", "대기열에 등록합니다...");
        try {
            const response = await fetch(`${getApiBase()}/api/queue/join`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ customerId: customerId })
            });
            if (!response.ok) throw new Error(`대기열 등록 실패: ${response.status}`);
            const result = await response.json();
            setText("status", `대기열에 성공적으로 등록되었습니다. 상담사 배정을 기다려주세요... (Ticket: ${result.ticketId})`);
        } catch (e) {
            setText("status", `오류 발생: ${e.message}`);
        }
    }

    async function startCall() {
        hide("waiting-ui");
        show("call-ui");

        try {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            $("localVideo").srcObject = localStream;
        } catch (e) {
            setText("status", "X getUserMedia 실패: " + e.message);
            return;
        }

        const iceConfiguration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
        pc = new RTCPeerConnection(iceConfiguration);

        pc.ondatachannel = (event) => {
            uiLog('[DC] received channel');
            dataChannel = event.channel;
            dataChannel.onmessage = handleDataChannelMessage;
            dataChannel.onopen = () => uiLog('[DC] opened');
            dataChannel.onclose = () => uiLog('[DC] closed');
        };

        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

        pc.ontrack = (event) => { $("remoteVideo").srcObject = event.streams[0]; };
        pc.onicecandidate = (event) => { if (event.candidate) wsSend("candidate", event.candidate); };
        pc.onconnectionstatechange = () => setText("pcStatus", `PC: ${pc.connectionState}`);
        pc.oniceconnectionstatechange = () => setText("iceStatus", `ICE: ${pc.iceConnectionState}`);
        setText("pcStatus", "PC: created");

        wsSend("join", {});
    }

    // --- Modified cleanup to include highlight clearing ---
    function cleanup() {
        if (pc) pc.close();
        if (localStream) localStream.getTracks().forEach(t => t.stop());
        if (ws && ws.readyState === 1) ws.close();
        
        hide("call-ui");
        hide("co-browsing-container");
        hide("signature-modal");
        hide("keyboard-modal");
        show("waiting-ui");
        setText("status", "상담이 종료되었습니다.");

        activeField = null;
    }
    // ---------------------------------------------------

    // --- Helper to clear any active field state ---
    function clearActiveFields() {
        activeField = null;
        hide('signature-modal');
        hide('keyboard-modal');
    }
    // --------------------------------------------

    function handleDataChannelMessage(event) {
        const msg = JSON.parse(event.data);
        uiLog('[DC <-]', msg.type);

        switch (msg.type) {
            case 'load_pdf':
                clearActiveFields();
                loadPdf(msg.payload.filename);
                break;
            case 'page_change':
                clearActiveFields();
                if (!isController) {
                    renderPage(msg.payload.page);
                }
                break;
            case 'mouse':
                if (!isController) {
                    const cursor = $('agent-cursor');
                    cursor.style.left = msg.payload.x + 'px';
                    cursor.style.top = msg.payload.y + 'px';
                    show(cursor.id);
                }
                break;
            case 'control_change':
                clearActiveFields();
                isController = msg.payload.controller === 'customer';
                uiLog(`Control changed. I am now ${isController ? 'the controller' : 'the viewer'}.`);
                if (isController) {
                    hide('agent-cursor');
                }
                break;
            case 'field_activation':
                // Clear any previous state before activating a new field
                clearActiveFields();
                
                const fieldToActivate = pdfFields.find(f => f.fieldId === msg.payload.fieldId);
                if (!fieldToActivate) {
                    uiLog(`Error: Field ${msg.payload.fieldId} not found.`);
                    return;
                }
                uiLog(`Field activated: ${fieldToActivate.fieldId} (Type: ${fieldToActivate.type})`);

                switch (fieldToActivate.type) {
                    case 'signature':
                        activeField = fieldToActivate;
                        show('signature-modal', 'flex');
                        if (!signaturePad) {
                            const canvas = $('signature-pad-canvas');
                            signaturePad = new SignaturePad(canvas);
                        } else {
                            signaturePad.clear();
                        }
                        break;
                    case 'checkbox':
                        // Checkboxes are always active, so agent activations are ignored.
                        uiLog("Checkbox activation is ignored, they are always active.");
                        break;
                    case 'keyboard':
                        activeField = fieldToActivate;
                        show('keyboard-modal', 'flex');
                        $('keyboard-input').value = fieldValues[activeField.fieldId] || ''; // Pre-fill
                        $('keyboard-input').focus();
                        break;
                }
                break;
            case 'field_updated':
                fieldValues[msg.payload.fieldId] = msg.payload.value;
                // The concept of a single highlighted field is gone, so no need to clear it.
                renderPage(currentPageNum);
                break;
        }
    }

    async function drawFieldValues(pageNumber, canvasContext, viewport) {
        const scale = viewport.scale;
        const fieldsOnPage = pdfFields.filter(f => f.page === pageNumber);
        for (const field of fieldsOnPage) {
            const value = fieldValues[field.fieldId];
            const { x, y, width, height } = field.rect;
            
            // FIX 1: Scale coordinates
            const scaledX = x * scale;
            const scaledWidth = width * scale;
            const scaledHeight = height * scale;
            const scaledY = y * scale;

            if (field.type === 'signature') {
                if (value) { // Only draw if there is a signature
                    const img = new Image();
                    img.src = value;
                    await new Promise(resolve => img.onload = resolve);
                    canvasContext.drawImage(img, scaledX, scaledY, scaledWidth, scaledHeight);
                }
            } else if (field.type === 'checkbox') {
                if (value === true) {
                    canvasContext.font = `${scaledHeight * 0.8}px Arial`;
                    canvasContext.fillStyle = 'green';
                    canvasContext.fillText('✔', scaledX, scaledY + scaledHeight * 0.9);
                }
            } else if (field.type === 'keyboard') {
                canvasContext.font = `${scaledHeight * 0.7}px Arial`;
                canvasContext.fillStyle = 'black';
                // FIX 2: Use || '' to prevent "undefined"
                canvasContext.fillText(value || '', scaledX, scaledY + scaledHeight * 0.7);
            }
        }
    }

    // --- New function to draw overlays for all active checkboxes ---
    function drawCheckboxOverlays(context, viewport, pageNumber) {
        const scale = viewport.scale;
        const fieldsOnPage = pdfFields.filter(f => f.page === pageNumber && f.type === 'checkbox');

        for (const field of fieldsOnPage) {
            const { x, y, width, height } = field.rect;
            const scaledX = x * scale;
            const scaledWidth = width * scale;
            const scaledHeight = height * scale;
            const scaledY = y * scale;

            context.save();
            context.fillStyle = "rgba(0, 128, 0, 0.25)"; // Semi-transparent green
            context.fillRect(scaledX, scaledY, scaledWidth, scaledHeight);
            context.strokeStyle = "green";
            context.lineWidth = 1;
            context.strokeRect(scaledX, scaledY, scaledWidth, scaledHeight);
            context.restore();
        }
    }
    // ------------------------------------------

    async function loadPdf(filename) {
        const url = `${getApiBase()}/documents/${filename}`;
        show('co-browsing-container');
        
        try {
            pdfDoc = await pdfjsLib.getDocument(url).promise;
            uiLog(`PDF loaded with ${pdfDoc.numPages} pages.`);
            currentPageNum = 1;
            
            // Fetch field definitions
            const jsonFilename = filename.replace('.pdf', '.json');
            try {
                const response = await fetch(`${getApiBase()}/documents/${jsonFilename}`);
                if (response.ok) {
                    pdfFields = await response.json();
                    uiLog(`Loaded ${pdfFields.length} fields for ${filename}`);
                } else {
                    pdfFields = [];
                    uiLog(`No field definitions found for ${filename}`);
                }
            } catch (error) {
                uiLog(`Error fetching field definitions: ${error}`);
                pdfFields = [];
            }

            clearActiveFields();
            fieldValues = {};

            renderPage(currentPageNum);
        } catch (error) {
            uiLog('Error loading PDF:', error);
        }
    }

    async function renderPage(num) {
        if (pdfIsLoading || !pdfDoc) return;
        pdfIsLoading = true;

        const page = await pdfDoc.getPage(num);

        const container = $("pdf-viewer-container");
        const scale = container.clientWidth / page.getViewport({ scale: 1.0 }).width;
        const viewport = page.getViewport({ scale: scale });

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        
        container.innerHTML = '<div id="agent-cursor"></div>';
        container.appendChild(canvas);
        
        await page.render({ canvasContext: context, viewport: viewport }).promise;
        uiLog(`Page ${num} rendered`);
        
        await drawFieldValues(num, context, viewport);

        // --- Draw overlays for all checkboxes ---
        drawCheckboxOverlays(context, viewport, num);
        // ----------------------------------------------------

        pdfIsLoading = false;

        currentPageNum = num;
        $("pdf-page-info").textContent = `${num} / ${pdfDoc.numPages}`;
        $("pdf-prev").disabled = num <= 1 || !isController;
        $("pdf-next").disabled = num >= pdfDoc.numPages || !isController;
    }
    
    // ===== Boot =====
    (function init() {
        setText("status", "서버에 연결 중...");
        ws = new WebSocket(getWsUrl());

        ws.onopen = () => {
            setText("wsStatus", "WS: connected");
            wsRegister();
            joinQueue();
        };

        ws.onclose = () => setText("wsStatus", "WS: closed");
        ws.onerror = () => setText("wsStatus", "WS: error");

        ws.onmessage = async (evt) => {
            let msg;
            try { msg = JSON.parse(evt.data); } 
            catch (e) { console.error("JSON parse failed", e, evt.data); return; }

            uiLog("[WS <-", msg.type);

            if (msg.type === "session-matched") {
                roomId = msg.sessionId;
                await startCall();
            } else if (msg.type === "offer") {
                await pc.setRemoteDescription(msg.payload);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                wsSend("answer", pc.localDescription);
            } else if (msg.type === "candidate") {
                 try { await pc.addIceCandidate(msg.payload); } 
                 catch(e) { console.error("Error adding received ice candidate", e); }
            } else if (msg.type === "ended") {
                cleanup();
            }
        };

        $("btnEndCall").onclick = () => {
            wsSend("ended", { reason: "customer_click" });
            cleanup();
        };

        // Signature pad event handlers
        $('signature-clear').onclick = () => signaturePad.clear();
        $('signature-confirm').onclick = () => {
            if (!activeField) return;
            if (signaturePad.isEmpty()) {
                alert("서명을 먼저 입력해주세요.");
            } else {
                const signatureImage = signaturePad.toDataURL();
                fieldValues[activeField.fieldId] = signatureImage;
                dcSend('field_updated', { fieldId: activeField.fieldId, value: signatureImage });
                hide('signature-modal');
                activeField = null;
                renderPage(currentPageNum);
            }
        };

        // Keyboard input modal handlers
        $('keyboard-confirm').onclick = () => {
            if (!activeField) return;
            const inputText = $('keyboard-input').value;
            fieldValues[activeField.fieldId] = inputText;
            dcSend('field_updated', { fieldId: activeField.fieldId, value: inputText });
            hide('keyboard-modal');
            activeField = null;
            renderPage(currentPageNum);
        };
        $('keyboard-cancel').onclick = () => {
            hide('keyboard-modal');
            activeField = null;
        };


        $("pdf-prev").onclick = () => {
            if (currentPageNum <= 1 || !isController) return;
            clearActiveFields();
            renderPage(currentPageNum - 1);
            dcSend('page_change', { page: currentPageNum });
        };

        $("pdf-next").onclick = () => {
            if (currentPageNum >= pdfDoc.numPages || !isController) return;
            clearActiveFields();
            renderPage(currentPageNum + 1);
            dcSend('page_change', { page: currentPageNum });
        };

        const throttledMouse = throttle((e) => {
            if (!isController) return;
            const container = $("pdf-viewer-container");
            const rect = container.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            dcSend('mouse', { x, y });
        }, 50);

        $("pdf-viewer-container").addEventListener('mousemove', throttledMouse);

        // --- New click listener for customer to interact with checkbox fields ---
        $("pdf-viewer-container").addEventListener('click', async (e) => {
            const container = $("pdf-viewer-container");
            const canvas = container.querySelector('canvas');
            if (!canvas || !pdfDoc) return;

            const page = await pdfDoc.getPage(currentPageNum);
            const scale = container.clientWidth / page.getViewport({ scale: 1.0 }).width;

            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // Find which checkbox was clicked
            const checkboxesOnPage = pdfFields.filter(f => f.page === currentPageNum && f.type === 'checkbox');

            for (const field of checkboxesOnPage) {
                const { x, y, width, height } = field.rect;
                const scaledX = x * scale;
                const scaledWidth = width * scale;
                const scaledHeight = height * scale;
                const scaledY = y * scale;

                if (clickX >= scaledX && clickX <= scaledX + scaledWidth &&
                    clickY >= scaledY && clickY <= scaledY + scaledHeight) {
                    
                    uiLog(`Customer clicked checkbox field: ${field.fieldId}`);

                    const fieldId = field.fieldId;
                    const currentValue = fieldValues[fieldId] || false;
                    fieldValues[fieldId] = !currentValue;

                    // Send update to agent
                    dcSend('field_updated', { fieldId: fieldId, value: fieldValues[fieldId] });

                    // Re-render to show the checkmark change. The overlay will be redrawn automatically.
                    renderPage(currentPageNum);
                    
                    return; // Stop after finding the first clicked checkbox
                }
            }
        });
        // -----------------------------------------------------------------------

    })();
</script>

</body>
</html>
