<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>상담 대기</title>
    <!-- Bootstrap and Bootswatch CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootswatch@5.3.2/dist/flatly/bootstrap.min.css">
    <style>
        html, body {
            height: 100%;
        }
        body {
            display: flex;
            flex-direction: column;
        }
        .main-container {
            flex-grow: 1;
            display: flex;
            overflow: hidden;
        }
        #video-sidebar {
            flex-shrink: 0;
            width: 320px;
            height: 100%;
            overflow-y: auto;
            background-color: #f8f9fa;
            padding: 1rem;
        }
        #main-content {
            flex-grow: 1;
            height: 100%;
            overflow-y: auto;
            padding: 1.5rem;
        }
        #logo-view {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100%;
            flex-direction: column;
            text-align: center;
        }
        #logo-view img {
            max-width: 200px;
            opacity: 0.8;
        }
        #pdf-viewer-container {
            border: 1px solid #dee2e6;
            border-radius: 0.375rem;
            min-height: 70vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        video {
            width: 100%;
            border-radius: 0.375rem;
            background-color: #000;
        }
        #agent-cursor {
            position: absolute;
            width: 24px;
            height: 24px;
            transform: translate(-50%, -50%);
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><circle cx="12" cy="12" r="6" fill="rgba(255, 0, 0, 0.4)"/><circle cx="12" cy="12" r="4" fill="red"/></svg>');
            background-size: contain;
            display: none;
            z-index: 10;
            pointer-events: none;
        }
        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6); display: none; justify-content: center; align-items: center; z-index: 1050;
        }
        .modal-content { background: #fff; padding: 20px; border-radius: 12px; text-align: center; max-width: 500px; width: 90%;}
        #signature-pad-canvas { border: 1px solid #ccc; border-radius: 8px; max-width: 100%; }
    </style>
</head>
<body class="bg-light">

<!-- Waiting UI (Centered) -->
<div id="waiting-ui" class="d-flex justify-content-center align-items-center h-100">
    <div class="card text-center shadow-sm">
        <div class="card-body p-5">
            <h1 class="card-title">상담 대기</h1>
            <p id="status" class="lead mt-3">상담사와 연결을 위해 대기열에 등록하고 있습니다.</p>
            <div class="spinner-border text-primary mt-3" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="text-muted mt-4">이 페이지를 닫지 마세요.</p>
        </div>
    </div>
</div>


<!-- Call UI -->
<div class="main-container" id="call-ui" style="display: none;">
    <!-- Left Sidebar for Videos and Controls -->
    <aside id="video-sidebar">
        <h5>상담</h5>
        <div class="d-grid gap-2 mb-4">
            <button id="btnEndCall" class="btn btn-danger">상담 종료</button>
        </div>
        
        <div class="card mb-3">
            <div class="card-header">Agent</div>
            <div class="card-body p-1">
                <video id="remoteVideo" autoplay playsinline style="transform: scaleX(-1);"></video>
            </div>
        </div>
        <div class="card">
            <div class="card-header">Me</div>
            <div class="card-body p-1">
                <video id="localVideo" autoplay playsinline muted style="transform: scaleX(-1);"></video>
            </div>
        </div>
    </aside>

    <!-- Main Content for Co-browsing -->
    <main id="main-content">
        <!-- Logo View (shown when not co-browsing) -->
        <div id="logo-view">
            <img src="/images/fermi-logo.svg" alt="Fermi Logo">
            <p class="lead mt-3 text-muted">상담사가 문서를 공유하면 여기에 표시됩니다.</p>
        </div>

        <!-- Co-browsing UI (initially hidden) -->
        <div id="co-browsing-container" style="display: none;">
            <div id="pdf-viewer-container" class="position-relative">
                <div id="agent-cursor"></div>
                <!-- Canvas for PDF page will be inserted here -->
            </div>
            <div id="pdf-pagination-controls" class="d-flex justify-content-center align-items-center gap-3 mt-3">
                <button id="pdf-prev" class="btn btn-outline-primary" disabled>&laquo; 이전</button>
                <span id="pdf-page-info" class="fw-bold"></span>
                <button id="pdf-next" class="btn btn-outline-primary" disabled>다음 &raquo;</button>
            </div>
        </div>
    </main>
</div>

<!-- Signature & Keyboard Modals -->
<div class="modal-overlay" id="signature-modal">
    <div class="modal-content">
        <p>아래 영역에 서명해주세요.</p>
        <canvas id="signature-pad-canvas" width="400" height="200"></canvas>
        <div><button id="signature-clear">다시 서명</button><button id="signature-confirm">서명 완료</button></div>
    </div>
</div>
<div class="modal-overlay" id="keyboard-modal">
    <div class="modal-content">
        <p>텍스트를 입력해주세요.</p>
        <input type="text" id="keyboard-input" placeholder="여기에 입력하세요" />
        <div><button id="keyboard-cancel">취소</button><button id="keyboard-confirm">확인</button></div>
    </div>
</div>

<!-- JS Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/signature_pad/1.5.3/signature_pad.min.js"></script>
<script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js`;
</script>

<script>
    const $ = (id) => document.getElementById(id);

    let roomId = "", customerId = `customer_${Math.random().toString(36).substring(2, 9)}`, ws = null, pc = null, localStream = null, dataChannel = null;
    let signaturePad = null, isController = false, pdfDoc = null, currentPageNum = 1, pdfIsLoading = false, pdfFields = [], fieldValues = {}, activeField = null;

    function getCurrentPdfScale(page) {
        const container = $("pdf-viewer-container");
        const mainContent = $("main-content");
        if (!page) return 1.0;

        const unscaledViewport = page.getViewport({ scale: 1.0 });
        const scaleToWidth = container.clientWidth / unscaledViewport.width;
        const scaleToHeight = (mainContent.clientHeight - 40) / unscaledViewport.height; 
        
        return Math.min(scaleToWidth, scaleToHeight);
    }

    function throttle(func, limit) {
        let inThrottle;
        return function() {
            const args = arguments;
            const context = this;
            if (!inThrottle) {
                func.apply(context, args);
                inThrottle = true;
                setTimeout(() => inThrottle = false, limit);
            }
        }
    }

    function setText(id, msg) { const el = $(id); if (el) el.textContent = msg; }
    function show(id, display = 'flex') { $(id).style.display = display; }
    function hide(id) { $(id).style.display = 'none'; }
    function getWsUrl() { return `${location.protocol === "https:" ? "wss" : "ws"}://${location.host}/ws`; }
    function getApiBase() { return location.origin; }
    function wsSend(type, payload) { if (ws && ws.readyState === 1) ws.send(JSON.stringify({ type, roomId, payload }));}
    function dcSend(type, payload) { if (dataChannel && dataChannel.readyState === 'open') dataChannel.send(JSON.stringify({ type, payload }));}
    function wsRegister() {
        const msg = { type: "register", userId: customerId };
        if (ws && ws.readyState === 1) {
            ws.send(JSON.stringify(msg));
        }
    }
    
    async function joinQueue() {
        setText("status", "대기열에 등록합니다...");
        try {
            const response = await fetch(`${getApiBase()}/api/queue/join`, {
                method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ customerId })
            });
            if (!response.ok) throw new Error(`대기열 등록 실패: ${response.status}`);
            const result = await response.json();
            setText("status", `대기열에 등록되었습니다. 상담사 배정을 기다려주세요... (Ticket: ${result.ticketId})`);
        } catch (e) {
            setText("status", `오류 발생: ${e.message}`);
        }
    }

    async function startCall() {
        $('waiting-ui').classList.add('d-none');
        show("call-ui", 'flex');
        show("logo-view", 'flex');
        hide("co-browsing-container");

        try {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            $("localVideo").srcObject = localStream;
        } catch (e) {
            console.error("getUserMedia failed:", e);
            return;
        }

        const iceConfiguration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
        pc = new RTCPeerConnection(iceConfiguration);
        pc.ondatachannel = (event) => {
            dataChannel = event.channel;
            dataChannel.onmessage = handleDataChannelMessage;
        };
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        pc.ontrack = (event) => { $("remoteVideo").srcObject = event.streams[0]; };
        pc.onicecandidate = (event) => { if (event.candidate) wsSend("candidate", event.candidate); };
        wsSend("join", {});
    }

    function cleanup() {
        if (pc) pc.close();
        if (localStream) localStream.getTracks().forEach(t => t.stop());
        if (ws && ws.readyState === 1) ws.close();
        
        hide("call-ui");
        $('waiting-ui').classList.remove('d-none');
        setText("status", "상담이 종료되었습니다. 5초 후 페이지가 새로고침됩니다.");

        setTimeout(() => location.reload(), 5000);
    }

    function clearActiveFields() {
        activeField = null;
        hide('signature-modal');
        hide('keyboard-modal');
    }

    function handleDataChannelMessage(event) {
        const msg = JSON.parse(event.data);
        switch (msg.type) {
            case 'load_pdf':
                clearActiveFields();
                pdfFields = msg.payload.fields || [];
                fieldValues = {};
                loadPdf(msg.payload.pdfUrl);
                break;
            case 'page_change':
                clearActiveFields();
                if (!isController) renderPage(msg.payload.page);
                break;
            case 'mouse':
                if (!isController) {
                    const container = $("pdf-viewer-container");
                    const canvas = container.querySelector('canvas');
                    if (!canvas) return;

                    // Calculate pixel position relative to the canvas
                    const pixelX = msg.payload.x * canvas.width;
                    const pixelY = msg.payload.y * canvas.height;

                    const cursor = $('agent-cursor');
                    // Position cursor relative to the container, accounting for canvas offset
                    cursor.style.left = (canvas.offsetLeft + pixelX) + 'px';
                    cursor.style.top = (canvas.offsetTop + pixelY) + 'px';
                    show(cursor.id, 'block');
                }
                break;
            case 'field_activation':
                clearActiveFields();
                const fieldToActivate = pdfFields.find(f => f.fieldId === msg.payload.fieldId);
                if (!fieldToActivate) return;
                activeField = fieldToActivate;
                switch (fieldToActivate.type) {
                    case 'signature':
                        show('signature-modal', 'flex');
                        if (!signaturePad) signaturePad = new SignaturePad($('signature-pad-canvas'));
                        else signaturePad.clear();
                        break;
                    case 'keyboard':
                        show('keyboard-modal', 'flex');
                        $('keyboard-input').value = fieldValues[activeField.fieldId] || '';
                        $('keyboard-input').focus();
                        break;
                }
                break;
            case 'field_updated':
                fieldValues[msg.payload.fieldId] = msg.payload.value;
                renderPage(currentPageNum);
                break;
        }
    }

    async function drawFieldValues(pageNumber, canvasContext, viewport) {
        const scale = viewport.scale;
        const fieldsOnPage = pdfFields.filter(f => f.page === pageNumber);
        for (const field of fieldsOnPage) {
            const value = fieldValues[field.fieldId];
            if (!value) continue;
            const { x, y, width, height } = field.rect;
            if (field.type === 'signature') {
                const img = new Image();
                img.src = value;
                await new Promise(resolve => img.onload = resolve);
                canvasContext.drawImage(img, x * scale, y * scale, width * scale, height * scale);
            } else if (field.type === 'checkbox' && value === true) {
                canvasContext.font = `${height * scale * 0.8}px Arial`;
                canvasContext.fillStyle = 'green';
                canvasContext.fillText('✔', x * scale, y * scale + height * scale * 0.9);
            } else if (field.type === 'keyboard') {
                canvasContext.font = `${height * scale * 0.7}px Arial`;
                canvasContext.fillStyle = 'black';
                canvasContext.fillText(value || '', x * scale, y * scale + height * scale * 0.7);
            }
        }
    }

    function drawCheckboxOverlays(context, viewport, pageNumber) {
        const scale = viewport.scale;
        const fieldsOnPage = pdfFields.filter(f => f.page === pageNumber && f.type === 'checkbox');
        fieldsOnPage.forEach(field => {
            const { x, y, width, height } = field.rect;
            context.save();
            context.fillStyle = "rgba(0, 128, 0, 0.25)";
            context.fillRect(x * scale, y * scale, width * scale, height * scale);
            context.strokeStyle = "green";
            context.lineWidth = 1;
            context.strokeRect(x * scale, y * scale, width * scale, height * scale);
            context.restore();
        });
    }

    async function loadPdf(url) {
        hide('logo-view');
        show('co-browsing-container', 'block');
        try {
            pdfDoc = await pdfjsLib.getDocument(url).promise;
            currentPageNum = 1;
            clearActiveFields();
            fieldValues = {};
            renderPage(currentPageNum);
        } catch (error) { console.error("Error loading PDF", error); }
    }

    async function renderPage(num) {
        if (pdfIsLoading || !pdfDoc) return;
        pdfIsLoading = true;
        const page = await pdfDoc.getPage(num);

        const scale = getCurrentPdfScale(page);
        const viewport = page.getViewport({ scale });
        
        const container = $("pdf-viewer-container");
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.height = viewport.height;
        canvas.width = viewport.width;
        container.innerHTML = '<div id="agent-cursor"></div>';
        container.appendChild(canvas);
        await page.render({ canvasContext: context, viewport }).promise;
        await drawFieldValues(num, context, viewport);
        drawCheckboxOverlays(context, viewport, num);
        pdfIsLoading = false;
        currentPageNum = num;
        $("pdf-page-info").textContent = `${num} / ${pdfDoc.numPages}`;
        $("pdf-prev").disabled = num <= 1 || !isController;
        $("pdf-next").disabled = num >= pdfDoc.numPages || !isController;
    }
    
    // ===== Boot =====
    document.addEventListener("DOMContentLoaded", () => {
        setText("status", "서버에 연결 중...");
        ws = new WebSocket(getWsUrl());
        ws.onopen = () => { 
            wsRegister(); 
            // Don't join queue immediately, wait for registration success
        };
        ws.onclose = () => { setText("status", "연결이 끊겼습니다. 페이지를 새로고침해주세요."); };
        ws.onmessage = async (evt) => {
            let msg;
            try { msg = JSON.parse(evt.data); } catch (e) { return; }

            if (msg.type === "register-success") {
                joinQueue(); // Now join the queue
            } else if (msg.type === "session-matched") {
                roomId = msg.sessionId;
                await startCall();
            } else if (msg.type === "offer") {
                await pc.setRemoteDescription(msg.payload);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                wsSend("answer", pc.localDescription);
            } else if (msg.type === "candidate") {
                 try { await pc.addIceCandidate(msg.payload); } catch(e) {}
            } else if (msg.type === "ended") {
                cleanup();
            }
        };

        $("btnEndCall").onclick = () => { wsSend("ended", { reason: "customer_click" }); cleanup(); };
        $('signature-clear').onclick = () => signaturePad.clear();
        $('signature-confirm').onclick = () => {
            if (!activeField || signaturePad.isEmpty()) return;
            const signatureImage = signaturePad.toDataURL();
            fieldValues[activeField.fieldId] = signatureImage;
            dcSend('field_updated', { fieldId: activeField.fieldId, value: signatureImage });
            hide('signature-modal');
            activeField = null;
            renderPage(currentPageNum);
        };
        $('keyboard-confirm').onclick = () => {
            if (!activeField) return;
            const inputText = $('keyboard-input').value;
            fieldValues[activeField.fieldId] = inputText;
            dcSend('field_updated', { fieldId: activeField.fieldId, value: inputText });
            hide('keyboard-modal');
            activeField = null;
            renderPage(currentPageNum);
        };
        $('keyboard-cancel').onclick = () => { hide('keyboard-modal'); activeField = null; };
        $("pdf-prev").onclick = () => {
            if (currentPageNum > 1 && isController) {
                clearActiveFields();
                renderPage(currentPageNum - 1);
                dcSend('page_change', { page: currentPageNum });
            }
        };
        $("pdf-next").onclick = () => {
            if (currentPageNum < pdfDoc.numPages && isController) {
                clearActiveFields();
                renderPage(currentPageNum + 1);
                dcSend('page_change', { page: currentPageNum });
            }
        };

        $("pdf-viewer-container").addEventListener('mousemove', throttle((e) => {
            if (!isController) return;
            const container = $("pdf-viewer-container");
            const rect = container.getBoundingClientRect();
            dcSend('mouse', { x: e.clientX - rect.left, y: e.clientY - rect.top });
        }, 50));

        $("pdf-viewer-container").addEventListener('click', async (e) => {
            const container = $("pdf-viewer-container");
            const canvas = container.querySelector('canvas');
            if (!canvas || !pdfDoc) return;
            const page = await pdfDoc.getPage(currentPageNum);
            const scale = getCurrentPdfScale(page);
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            const checkboxesOnPage = pdfFields.filter(f => f.page === currentPageNum && f.type === 'checkbox');
            for (const field of checkboxesOnPage) {
                const { x, y, width, height } = field.rect;
                const scaledX = x * scale, scaledY = y * scale, scaledWidth = width * scale, scaledHeight = height * scale;
                if (clickX >= scaledX && clickX <= scaledX + scaledWidth && clickY >= scaledY && clickY <= scaledY + scaledHeight) {
                    const fieldId = field.fieldId;
                    fieldValues[fieldId] = !fieldValues[fieldId];
                    dcSend('field_updated', { fieldId, value: fieldValues[fieldId] });
                    renderPage(currentPageNum);
                    return;
                }
            }
        });
    });
</script>
</body>
</html>