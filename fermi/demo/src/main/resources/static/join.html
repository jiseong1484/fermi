<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>상담 대기</title>
    <style>
        body { font-family: system-ui, -apple-system, sans-serif; padding: 16px; max-width: 960px; margin: 0 auto; }
        .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin: 12px 0; }
        button { padding: 10px 12px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
        video { width: 100%; max-height: 320px; background: #000; border-radius: 12px; }
        .hint { color: #555; font-size: 14px; }
        pre { background: #f6f6f6; padding: 10px; border-radius: 10px; overflow: auto; }
        #call-ui { display: none; }
    </style>
</head>
<body>
<h1>고객 페이지</h1>

<div class="card" id="waiting-ui">
    <h2>상담 대기 중...</h2>
    <p id="status">상담사와 연결을 위해 대기열에 등록하고 있습니다.</p>
    <p class="hint">이 페이지를 닫지 마세요.</p>
</div>

<div class="card" id="call-ui">
    <div class="hint" id="wsStatus">WS: -</div>
    <div class="hint" id="pcStatus">PC: -</div>
    <div class="hint" id="iceStatus">ICE: -</div>
    <button id="btnEndCall" style="margin-top:8px;">통화 종료</button>

    <div style="display: flex; gap: 1rem; margin-top: 1rem;">
        <div style="flex:1; min-width: 320px;">
            <div class="hint">Local</div>
            <video id="localVideo" autoplay playsinline muted style="transform: scaleX(-1);"></video>
        </div>
        <div style="flex:1; min-width: 320px;">
            <div class="hint">Remote</div>
            <video id="remoteVideo" autoplay playsinline style="transform: scaleX(-1);"></video>
        </div>
    </div>
</div>

<pre id="log"></pre>

<script>
    const $ = (id) => document.getElementById(id);

    let roomId = "";
    let customerId = `customer_${Math.random().toString(36).substring(2, 9)}`;
    let ws = null;
    let pc = null;
    let localStream = null;

    function uiLog(...args) {
        console.log(...args);
        const el = $("log");
        el.textContent += args.map(a => (typeof a === "string" ? a : JSON.stringify(a))).join(" ") + "\n";
        el.scrollTop = el.scrollHeight;
    }
    function setText(id, msg) { const el = $(id); if (el) el.textContent = msg; }
    function show(id) { $(id).style.display = 'block'; }
    function hide(id) { $(id).style.display = 'none'; }


    function getWsUrl() {
        const proto = location.protocol === "https:" ? "wss" : "ws";
        return `${proto}://${location.host}/ws`;
    }

    function getApiBase() {
        return location.origin;
    }

    function wsSend(type, payload) {
        const msg = { type, roomId, payload };
        uiLog("[WS ->]", type, "room=", roomId);
        if (!ws || ws.readyState !== 1) {
            uiLog("!! WS not ready");
            return;
        }
        ws.send(JSON.stringify(msg));
    }

    function wsRegister() {
        const msg = { type: "register", userId: customerId };
        uiLog("[WS ->] register", msg);
        ws.send(JSON.stringify(msg));
    }
    
    async function joinQueue() {
        setText("status", "대기열에 등록합니다...");
        try {
            const response = await fetch(`${getApiBase()}/api/queue/join`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ customerId: customerId })
            });

            if (!response.ok) {
                throw new Error(`대기열 등록 실패: ${response.status}`);
            }
            
            const result = await response.json();
            setText("status", `대기열에 성공적으로 등록되었습니다. 상담사 배정을 기다려주세요... (Ticket: ${result.ticketId})`);
            uiLog("[API] Joined queue successfully", result);

        } catch (e) {
            setText("status", `오류 발생: ${e.message}`);
            uiLog("[API] Error joining queue", e);
        }
    }


    async function startCall() {
        hide("waiting-ui");
        show("call-ui");

        // Media
        try {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            $("localVideo").srcObject = localStream;
        } catch (e) {
            setText("status", "X getUserMedia 실패: " + e.message);
            return ;
        }
        uiLog("[MEDIA] local stream ready");

        // PC
        pc = new RTCPeerConnection({ iceServers: [] });
        for (const track of localStream.getTracks()) pc.addTrack(track, localStream);

        pc.ontrack = (event) => {
            $("remoteVideo").srcObject = event.streams[0];
            uiLog("[PC] ontrack remote stream");
        };

        pc.onicecandidate = (event) => {
            if (event.candidate) {
                uiLog("[ICE local] generated");
                wsSend("candidate", event.candidate);
            }
        };
        
        pc.onconnectionstatechange = () => setText("pcStatus", `PC: ${pc.connectionState}`);
        pc.oniceconnectionstatechange = () => setText("iceStatus", `ICE: ${pc.iceConnectionState}`);

        setText("pcStatus", "PC: created");

        // Join the room received from the server
        wsSend("join", {});
    }

    function cleanup() {
        try { if (pc) pc.close(); } catch (e) {}
        pc = null;
        try { if (localStream) localStream.getTracks().forEach(t => t.stop()); } catch (e) {}
        localStream = null;
        try { if (ws && ws.readyState === 1) ws.close(); } catch (e) {}
        ws = null;
        
        setText("status", "상담이 종료되었습니다.");
        hide("call-ui");
        show("waiting-ui");
    }

    // ===== Boot =====
    (function init() {
        setText("status", "서버에 연결 중...");

        ws = new WebSocket(getWsUrl());
        uiLog("[WS] connecting to", ws.url);

        ws.onopen = () => {
            setText("wsStatus", "WS: connected");
            uiLog("[WS] open");
            
            // 1. Register this client with its unique customerId
            wsRegister();
            
            // 2. Join the waiting queue
            joinQueue();
        };

        ws.onclose = () => {
            setText("wsStatus", "WS: closed");
            uiLog("[WS] close");
        };

        ws.onerror = () => {
            setText("wsStatus", "WS: error");
            uiLog("[WS] error");
        };

        ws.onmessage = async (evt) => {
            let msg;
            try { msg = JSON.parse(evt.data); } 
            catch (e) { console.error("JSON parse failed", e, evt.data); return; }

            uiLog("[WS <-]", msg);

            // This is the message from the MatchingService
            if (msg.type === "session-matched") {
                roomId = msg.sessionId;
                uiLog(`Matched! SessionId (roomId): ${roomId}`);
                await startCall();
            }
            
            // Standard WebRTC signaling
            else if (msg.type === "offer") {
                await pc.setRemoteDescription(msg.payload);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                wsSend("answer", pc.localDescription);
            } else if (msg.type === "candidate") {
                 try {
                    await pc.addIceCandidate(msg.payload);
                } catch(e) {
                    console.error("Error adding received ice candidate", e);
                }
            } else if (msg.type === "ended") {
                uiLog("[CALL] ended by peer", msg.payload);
                cleanup();
            }
        };

        const endBtn = $("btnEndCall");
        if (endBtn) endBtn.onclick = () => {
            wsSend("ended", { reason: "customer_click" });
            cleanup();
        };
    })();
</script>

</body>
</html>
